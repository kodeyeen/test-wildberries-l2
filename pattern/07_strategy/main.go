package strategy

/*
Стратегия — это поведенческий паттерн проектирования,
который определяет семейство схожих алгоритмов и помещает каждый из них в собственный класс,
после чего алгоритмы можно взаимозаменять прямо во время исполнения программы.

Применимость:
1. Когда нужно использовать разные вариации какого-то алгоритма внутри одного объекта.
Стратегия позволяет варьировать поведение объекта во время выполнения программы,
подставляя в него различные объекты-поведения (например, отличающиеся балансом скорости и потребления ресурсов).
2. Когда есть множество похожих классов, отличающихся только некоторым поведением.
Стратегия позволяет вынести отличающееся поведение в отдельную иерархию классов,
а затем свести первоначальные классы к одному, сделав поведение этого класса настраиваемым.
3. Когда мы не хотим обнажать детали реализации алгоритмов для других классов.
Стратегия позволяет изолировать код, данные и зависимости алгоритмов от других объектов,
скрыв эти детали внутри классов-стратегий.
4. Когда различные вариации алгоритмов реализованы в виде развесистого условного оператора.
Каждая ветка такого оператора представляет собой вариацию алгоритма.
Стратегия помещает каждую лапу такого оператора в отдельный класс-стратегию.
Затем контекст получает определённый объект-стратегию от клиента и делегирует ему работу.
Если вдруг понадобится сменить алгоритм, в контекст можно подать другую стратегию.

Плюсы:
1. Горячая замена алгоритмов на лету.
2. Изолирует код и данные алгоритмов от остальных классов.
3. Уход от наследования к делегированию.
4. Реализует принцип открытости/закрытости.

Минусы:
1. Усложняет программу за счёт дополнительных классов.
2. Клиент должен знать, в чём состоит разница между стратегиями, чтобы выбрать подходящую.

Пример:
Представим, что мы разрабатываем «In-Memory-Cache».
Поскольку он находится внутри памяти, его размер ограничен.
Как только он полностью заполнится, какие-то записи придется убрать для освобождения места.
Эту функцию можно реализовать с помощью нескольких алгоритмов, самые популярные среди них:
	1) наиболее давно использовавшиеся (Least Recently Used – LRU): убирает запись, которая использовалась наиболее давно.
    2) «Первым пришел, первым ушел» (First In, First Out — FIFO): убирает запись, которая была создана раньше остальных
    3) наименее часто использовавшиеся (Least Frequently Used — LFU): убирает запись, которая использовалась наименее часто.

Проблема заключается в том, чтобы отделить кэш от этих алгоритмов для возможности их замены «на ходу».
Помимо этого, класс кэша не должен меняться при добавлении нового алгоритма.

В такой ситуации нам поможет паттерн Стратегия.
Он предполагает создание семейства алгоритмов, каждый из которых имеет свой класс.
Все классы применяют одинаковый интерфейс, что делает алгоритмы взаимозаменяемыми внутри этого семейства.
Назовем этот общий интерфейс evictionAlgo.

Теперь основной класс нашего кэша будет включать в себя evictionAlgo.
Вместо прямой реализации всех типов алгоритмов вытеснения внутри самого себя,
наш класс будет передавать их в evictionAlgo.
Поскольку это интерфейс, мы можем непосредственно во время выполнения программы менять алгоритм на LRU, FIFO, LFU без изменений в классе кэша.
*/

func main() {
	// создаем объект одного из алгоритмов (одной из стратегий)
	lfu := &Lfu{}
	cache := initCache(lfu)

	// заполним кэш данными
	cache.add("a", "1")
	cache.add("b", "2")

	cache.add("c", "3")

	// создаем объект другого алгоритма
	lru := &Lru{}

	// меняем алгоритм очистки кэша
	cache.setEvictionAlgo(lru)

	// добавим еще
	cache.add("d", "4")

	// создаем еще один объект
	fifo := &Fifo{}

	// и снова меняем алгоритим
	cache.setEvictionAlgo(fifo)

	cache.add("e", "5")
}
